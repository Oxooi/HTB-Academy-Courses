
<h1>Other Upload Attacks</h1>
<hr/>
<p>In addition to arbitrary file uploads and limited file upload attacks, there are a few other techniques and attacks worth mentioning, as they may become handy in some web penetration tests or bug bounty tests. Let's discuss some of these techniques and when we may use them.</p>
<hr/>
<h2>Injections in File Name</h2>
<p>A common file upload attack uses a malicious string for the uploaded file name, which may get executed or processed if the uploaded file name is displayed (i.e., reflected) on the page. We can try injecting a command in the file name, and if the web application uses the file name within an OS command, it may lead to a command injection attack.</p>
<p>For example, if we name a file <code>file$(whoami).jpg</code> or <code>file`whoami`.jpg</code> or <code>file.jpg||whoami</code>, and then the web application attempts to move the uploaded file with an OS command (e.g. <code>mv file /tmp</code>), then our file name would inject the <code>whoami</code> command, which would get executed, leading to remote code execution. You may refer to the <a href="/module/details/109">Command Injections</a> module for more information.</p>
<p>Similarly, we may use an XSS payload in the file name (e.g. <code>&lt;script&gt;alert(window.origin);&lt;/script&gt;</code>), which would get executed on the target's machine if the file name is displayed to them. We may also inject an SQL query in the file name (e.g. <code>file';select+sleep(5);--.jpg</code>), which may lead to an SQL injection if the file name is insecurely used in an SQL query.</p>
<hr/>
<h2>Upload Directory Disclosure</h2>
<p>In some file upload forms, like a feedback form or a submission form, we may not have access to the link of our uploaded file and may not know the uploads directory. In such cases, we may utilize fuzzing to look for the uploads directory or even use other vulnerabilities (e.g., LFI/XXE) to find where the uploaded files are by reading the web applications source code, as we saw in the previous section. Furthermore, the <a href="/module/details/134">Web Attacks/IDOR</a> module discusses various methods of finding where files may be stored and identifying the file naming scheme.</p>
<p>Another method we can use to disclose the uploads directory is through forcing error messages, as they often reveal helpful information for further exploitation. One attack we can use to cause such errors is uploading a file with a name that already exists or sending two identical requests simultaneously. This may lead the web server to show an error that it could not write the file, which may disclose the uploads directory. We may also try uploading a file with an overly long name (e.g., 5,000 characters). If the web application does not handle this correctly, it may also error out and disclose the upload directory.</p>
<p>Similarly, we may try various other techniques to cause the server to error out and disclose the uploads directory, along with additional helpful information.</p>
<hr/>
<h2>Windows-specific Attacks</h2>
<p>We can also use a few <code>Windows-Specific</code> techniques in some of the attacks we discussed in the previous sections.</p>
<p>One such attack is using reserved characters, such as (<code>|</code>, <code>&lt;</code>, <code>&gt;</code>, <code>*</code>, or <code>?</code>), which are usually reserved for special uses like wildcards. If the web application does not properly sanitize these names or wrap them within quotes, they may refer to another file (which may not exist) and cause an error that discloses the upload directory. Similarly, we may use Windows reserved names for the uploaded file name, like (<code>CON</code>, <code>COM1</code>, <code>LPT1</code>, or <code>NUL</code>), which may also cause an error as the web application will not be allowed to write a file with this name.</p>
<p>Finally, we may utilize the Windows <a href="https://en.wikipedia.org/wiki/8.3_filename">8.3 Filename Convention</a> to overwrite existing files or refer to files that do not exist. Older versions of Windows were limited to a short length for file names, so they used a Tilde character (<code>~</code>) to complete the file name, which we can use to our advantage.</p>
<p>For example, to refer to a file called (<code>hackthebox.txt</code>) we can use (<code>HAC~1.TXT</code>) or (<code>HAC~2.TXT</code>), where the digit represents the order of the matching files that start with (<code>HAC</code>). As Windows still supports this convention, we can write a file called (e.g. <code>WEB~.CONF</code>) to overwrite the <code>web.conf</code> file. Similarly, we may write a file that replaces sensitive system files. This attack can lead to several outcomes, like causing information disclosure through errors, causing a DoS on the back-end server, or even accessing private files.</p>
<hr/>
<h2>Advanced File Upload Attacks</h2>
<p>In addition to all of the attacks we have discussed in this module, there are more advanced attacks that can be used with file upload functionalities. Any automatic processing that occurs to an uploaded file, like encoding a video, compressing a file, or renaming a file, may be exploited if not securely coded.</p>
<p>Some commonly used libraries may have public exploits for such vulnerabilities, like the AVI upload vulnerability leading to XXE in <code>ffmpeg</code>. However, when dealing with custom code and custom libraries, detecting such vulnerabilities requires more advanced knowledge and techniques, which may lead to discovering an advanced file upload vulnerability in some web applications.</p>
<p>There are many other advanced file upload vulnerabilities that we did not discuss in this module. Try to read some bug bounty reports to explore more advanced file upload vulnerabilities.</p>
