
<h1>Captive Portal Usage and Lab Setup</h1>
<hr/>
<p>Captive portals serve as an additional authentication layer for public networks that do not rely on pre-shared keys (PSKs) or other traditional authentication methods. These networks are commonly found in public places such as hotels, airports, and cafes, where authentication may be based on room numbers, email addresses, or temporary access codes.</p>
<p>However, captive portals are inherently less secure than networks using WPA2, WPA3, or WPA-Enterprise, which implement strong encryption and authentication handshakes. The key distinction is that while captive portals may require user credentials (e.g., username and password), authentication is handled at the web application level rather than through a cryptographic handshake, as seen in WPA-based networks.</p>
<p>Some advanced captive portal systems do enhance security by redirecting users to an encrypted network after pre-authentication, but many public implementations remain vulnerable to various attacks.</p>
<p><img alt="Captive_Portal" src="https://academy.hackthebox.com/storage/modules/299/hostile/captive.png"/></p>
<hr/>
<h2>Understanding Captive Portal Systems</h2>
<p>Captive portal implementations can vary significantly, making it essential to understand their core components and how they function. Below is a breakdown of the key elements that make up these systems:</p>
<table>
<thead>
<tr>
<th>Component</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Access Points</td>
<td>These serve as relays for authentication, providing wireless connectivity to client devices. They do not perform authentication themselves but forward traffic to the captive portal system.</td>
</tr>
<tr>
<td>Captive Portal Web Server</td>
<td>This server acts as the authentication gateway. Until authentication is completed, all traffic is either blocked or redirected (typically to ports 80/443) using routing rules, DNS manipulation, or other methods.</td>
</tr>
<tr>
<td>Routers</td>
<td>In many setups, the router also functions as the captive portal web server. It bridges the connection to the public internet and ensures that only authenticated users are granted access.</td>
</tr>
<tr>
<td>Backend Databases/Storage</td>
<td>Authentication data is stored and validated here. This can be a RADIUS server, SQL database, JSON file, or another form of storage. When a user submits credentials, the system checks them against this database before granting access.</td>
</tr>
</tbody>
</table>
<p>Understanding how these components interact allows us to analyze potential attack vectors and identify weak points in captive portal security.</p>
<hr/>
<h2>Traffic Redirection in Captive Portals</h2>
<p>Captive portals rely on traffic redirection and blocking to enforce authentication. If unrestricted access were allowed, users would bypass the authentication process entirely. Therefore, controlling traffic flow is a critical aspect of captive portal functionality.</p>
<h4>Simulating Traffic Redirection in a Captive Portal</h4>
<p>To recreate traffic redirection or blocking, we can enable or disable IP forwarding. This determines whether traffic can pass through the network gateway.</p>
<p>Enable IP Forwarding (Allow traffic to cross the bridge):</p>
<pre><code class="language-shell-session">[!bash!]$ sudo echo 1 &gt; /proc/sys/net/ipv4/ip_forward
</code></pre>
<p>Disable IP Forwarding (Block traffic from crossing the bridge):</p>
<pre><code class="language-shell-session">[!bash!]$ sudo echo 0 &gt; /proc/sys/net/ipv4/ip_forward
</code></pre>
<p>By manipulating IP forwarding, we can simulate the behavior of captive portals and understand how they control network access. Many systems also use iptables rules, DNS redirection, or DHCP configurations to enforce authentication before granting full network access.</p>
<hr/>
<h2>Captive Portal Traffic Control with IPTables</h2>
<p>Captive portals manage network access using NAT (Network Address Translation) and iptables rules to control how traffic flows before and after authentication. The redirection process involves prerouting, postrouting, and forwarding to ensure unauthorized users are redirected to the login page.</p>
<h4>Step 1: NAT Masquerading (Postrouting)</h4>
<p>Captive portals use NAT masquerading to allow clients on the LAN to access the public internet through a single IP address:</p>
<pre><code class="language-shell-session">[!bash!]$ sudo iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE
</code></pre>
<p>Here, eth0 is the outgoing interface connecting to the internet.</p>
<h4>Step 2: Traffic Forwarding</h4>
<p>Most captive portals have two network interfaces:</p>
<ul>
<li>
<code>eth0</code> → Connects to the internet</li>
<li>
<code>eth1</code> → Connects to the access point (AP)</li>
</ul>
<p>Traffic from the AP to the internet is allowed using:</p>
<pre><code class="language-shell-session">[!bash!]$ sudo iptables -A FORWARD -i eth0 -o eth1 -j ACCEPT
</code></pre>
<p>However, unrestricted forwarding would let users bypass the captive portal.</p>
<h4>Step 3: Blocking Unauthorized Traffic</h4>
<p>To enforce authentication, captive portals block all traffic by default. Only authenticated users are allowed through.</p>
<h4>Step 4: Redirecting HTTP/HTTPS to the Captive Portal</h4>
<p>Until authentication is complete, all HTTP (port 80) and HTTPS (port 443) traffic is redirected to the captive portal login page:</p>
<pre><code class="language-shell-session">[!bash!]$ sudo iptables -t nat -A PREROUTING -p tcp --dport 80 -j DNAT --to-destination 192.168.0.1:80
[!bash!]$ sudo iptables -t nat -A PREROUTING -p tcp --dport 443 -j DNAT --to-destination 192.168.0.1:80
</code></pre>
<p>Here, 192.168.0.1:80 is the captive portal web server, which intercepts requests and presents a login page. This approach ensures that only authenticated users gain internet access, enforcing user validation and network control.</p>
<hr/>
<h2>Captive Portal Authentication Process</h2>
<p>The captive portal web application plays a crucial role in authenticating users before granting them internet access. It verifies user credentials or other identifying information against a backend database and then modifies iptables rules to allow traffic from the authenticated device.</p>
<h4>1. User Authentication Inputs</h4>
<p>Different captive portals require different forms of authentication:</p>
<ul>
<li>Room Number (e.g., in hotels)</li>
<li>Username and Password (e.g., enterprise networks)</li>
<li>Session Key (e.g., public Wi-Fi with a "click to accept" login page)</li>
</ul>
<p>Once submitted, the captive portal validates this information against a backend, such as:</p>
<ul>
<li>RADIUS Server (e.g., WPA2-Enterprise networks)</li>
<li>SQL Databases (e.g., guest authentication)</li>
<li>Flat JSON/Local Files (e.g., small-scale deployments)</li>
</ul>
<h4>2. Granting Access After Authentication</h4>
<p>Upon successful authentication, the captive portal creates rules in iptables to allow the authenticated device access to the network. These rules are typically based on:</p>
<ul>
<li>MAC Address</li>
<li>IP Address (IPv4/IPv6)</li>
<li>Hostname</li>
</ul>
<p>If authentication is tied to the MAC address, the following rules allow HTTP/HTTPS traffic:</p>
<pre><code class="language-shell-session">[!bash!]$ sudo iptables -t filter -A FORWARD -m mac --mac-source XX:XX:XX:XX:XX:XX -p tcp --dport 80 -j ACCEPT
[!bash!]$ sudo iptables -t filter -A FORWARD -m mac --mac-source XX:XX:XX:XX:XX:XX -p tcp --dport 443 -j ACCEPT
</code></pre>
<div class="alert alert-primary fade show" role="alert">
<i class="mdi mdi-information-outline mr-2"></i> <b> Security Concern:</b> MAC addresses can be easily spoofed.
</div>
<p>If authentication is linked to the IPv4 or IPv6 address, the following rules allow traffic:</p>
<pre><code class="language-shell-session"># IPv4 Authentication
[!bash!]$ sudo iptables -t filter -A FORWARD -s 192.168.0.15 -p tcp --dport 80 -j ACCEPT
[!bash!]$ sudo iptables -t filter -A FORWARD -s 192.168.0.15 -p tcp --dport 443 -j ACCEPT

# IPv6 Authentication
[!bash!]$ sudo ip6tables -t filter -A FORWARD -s 2001:db8:1234::1/64 -p tcp --dport 80 -j ACCEPT
[!bash!]$ sudo ip6tables -t filter -A FORWARD -s 2001:db8:1234::1/64 -p tcp --dport 443 -j ACCEPT
</code></pre>
<div class="alert alert-primary fade show" role="alert">
<i class="mdi mdi-information-outline mr-2"></i> <b> Security Concern:</b> IP addresses can be changed or spoofed with proxy/VPN tunnels.
</div>
<p>If authentication is tied to the hostname, a string-matching rule is used:</p>
<pre><code class="language-shell-session">[!bash!]$ sudo iptables -t filter -A FORWARD -m string --string "safehtbclient.local" --algo bm --from 1 -p tcp --dport 80 -j ACCEPT
[!bash!]$ sudo iptables -t filter -A FORWARD -m string --string "safehtbclient.local" --algo bm --from 1 -p tcp --dport 443 -j ACCEPT
</code></pre>
<div class="alert alert-primary fade show" role="alert">
<i class="mdi mdi-information-outline mr-2"></i> <b> Security Concern:</b> Hostnames can be manipulated, making this method less reliable.
</div>
<p>In many cases, these system commands can be handled by the PHP authentication script, or whatever language the authentication script is written in. We can explore a couple examples of this authentication process.</p>
<h4>Room Number PHP Verification</h4>
<pre><code class="language-php">&lt;?php
// Retrieve the client's IP address
$ip_address = $_SERVER['REMOTE_ADDR'];

// Lookup the Client's MAC address
$mac_address = shell_exec("arp $ip_address | awk '{print $4}'");

// Get the room number from the form input
$roomnumber = $_POST['roomnumber'];

if (in_array($roomnumber, array('101', '102', '103', '201', '202', '203', '301', '302', '303'))) {
  // Allow Authenticated Client Traffic
  shell_exec("sudo iptables -t filter -A FORWARD -m mac --mac-source  " . $mac_address . " -p tcp --dport 80 -j ACCEPT");
  shell_exec("sudo iptables -t filter -A FORWARD -m mac --mac-source " . $mac_address . " -p tcp --dport 443 -j ACCEPT");
  echo "Thank you and welcome to the HTB Hotel Wireless Network.";
} else {
  // Room does not exist in our system
  echo "Sorry, the room number is not one of ours. Please try again.";
}
</code></pre>
<p>In this example, the web application retrieves the client's IP address and attempts to determine the corresponding MAC address via an ARP lookup. It then verifies the entered room number against a predefined list of authorized rooms. If the room number is valid, the application dynamically modifies the firewall rules (using iptables) to permit network traffic from the client device. This approach relies on MAC address filtering for authentication, which is inherently weak, as MAC addresses can be easily spoofed.</p>
<p>This example demonstrates MAC address-based authentication, a common approach in many captive portal systems. However, authentication can also be implemented using various backend databases, such as SQL, RADIUS, or JSON-based storage, as well as predefined arrays within the application. While MAC-based authentication provides a straightforward method for controlling network access, it is inherently insecure due to the ease of MAC address spoofing. More robust implementations often integrate additional verification methods, such as username/password authentication, certificate-based authentication, or multi-factor authentication (MFA), to enhance security.</p>
<h4>Username and Password Verification</h4>
<pre><code class="language-php">&lt;?php
// Retrieve the client's IP address
$ip_address = $_SERVER['REMOTE_ADDR'];

// Lookup the Client's MAC address
$mac_address = shell_exec("arp $ip_address | awk '{print $4}'");

// Get the username and password from the form input
$username = $_POST['username'];
$password = $_POST['password'];

// Connect to the database
$servername = "localhost";
$dbname = "htbDB";
$username = "admin";
$password = "password123";

$conn = new mysqli($servername, $username, $password, $dbname);

// Check connection
if ($conn-&gt;connect_error) {
    die("Connection failed: " . $conn-&gt;connect_error);
}

// Prepare and execute the SQL query with user input directly in the query string
$query = "SELECT * FROM authenticated_users WHERE username = '$username' AND password = MD5(BASE64('$password'))";
$result = $conn-&gt;query($query);

if ($result-&gt;num_rows &gt; 0) {
    // Allow Authenticated Client Traffic
    shell_exec("sudo iptables -t filter -A FORWARD -m mac --mac-source  " . $mac_address . " -p tcp --dport 80 -j ACCEPT");
    shell_exec("sudo iptables -t filter -A FORWARD -m mac --mac-source " . $mac_address . " -p tcp --dport 443 -j ACCEPT");
    echo "Thank you and welcome to the HTB Wireless Network, " . $username . ".";
} else {
    // Username and/or password do not exist in our system
    echo "Sorry, your username and/or password do not match our records. Please try again.";
}

$stmt-&gt;close();
$conn-&gt;close();
</code></pre>
<p>In this example, users authenticate to the wireless network using a preset username and password, a common approach in guest network captive portals. However, the implementation introduces a critical security flaw: the username and password are passed directly into the SQL query string, making it vulnerable to SQL injection (SQLi).</p>
<p>An attacker could exploit this weakness by injecting specially crafted SQL syntax into the username field, potentially bypassing authentication. This could lead to credential retrieval, allowing attackers to extract stored passwords, decode base64-encoded data, and crack MD5 hashes. Alternatively, an attacker might be able to insert their own account into the database, gaining persistent access.</p>
<p>Ultimately, captive portals function as authentication layers for public networks, but without proper security measures, they can introduce significant vulnerabilities.</p>
<hr/>
<h2>Lab Setup</h2>
<p>In the lab environment, connect to the open Wi-Fi network named <code>HTB-Guest</code>.</p>
<p><img alt="Intro" src="https://academy.hackthebox.com/storage/modules/299/macspoof/connect_general.PNG"/></p>
<p>Once connected, open a browser and visit <code>http://captive.htb.local</code> to access the captive portal.</p>
<img class="website-screenshot" data-url="http://captive.htb.local" src="https://academy.hackthebox.com/storage/modules/299/vpn/001.PNG"/>
<p>The final objective is to bypass the captive portal using various methods covered in the module and retrieve the flag.</p>
<img class="website-screenshot" data-url="http://captive.htb.local" src="https://academy.hackthebox.com/storage/modules/299/vpn/002.png"/>
<hr/>
<h2>Final Thoughts</h2>
<ul>
<li>
<code>MAC-based rules</code> are easiest to implement but also easiest to spoof.</li>
<li>
<code>IP-based rules</code> work but require static IP leases or DHCP reservation.</li>
<li>
<code>Hostname-based rules</code> are rarely used due to spoofing risks.</li>
</ul>
<p>In the next section, we will explore how we can structure our attacks to be more successful, along with some preliminary reconnaissance that we can perform.</p>
